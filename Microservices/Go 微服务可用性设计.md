## Go 微服务可用性设计
### 隔离
#### 服务隔离
##### 动静隔离
如 CND 缓存加速、mysql LRU 算法改进

**业务可以拆成两张表，静态表（字段机会不会改）和动态表（字段经常改）**
##### 读写隔离
* 主从
* CQRS
#### 轻重隔离
* 核心：服务按核心与否进行分离，越核心的服务可用性要求也高
* 快慢
* 热点
  * 小表广播: 存为到内存，定期更新
  * 主动预热：旁路预热

#### 物理隔离
* 线程：使用线程池，不同业务逻辑用不同的池子
* 进程：容器化
* 集群：region.zone.cluster.appid
* 机房

### 超时控制
核心理念： fail fast
#### 起因
* 网络具有不确定性
* 客户端和服务端不一致的超时策略

##### 方案
* 进程内：每一个请求前查看是否有剩余时间，并继承超时策略
* 服务间： GRPC 支持基于 grpc-timeout 的 Header 传递
* 监控要看 95th、99th

### 过载保护
#### 常见限流算法
* 令牌桶：按固定速率往桶里加令牌，可以消费多个令牌
* 漏斗桶： 按固定速率流出水滴，可以以任意速率流入水滴

痛点：阈值不好设置
#### 自适应过载保护
inflight: 当前服务正在进行的请求数量（atomic.add 来加减）
pass: 每个采样窗口内成功的请求数
rt: 单个采样窗口的平均 响应时间

CPU 统计：使用独立的 goroutine 每隔 250ms 统计一次，计算均值时，使用简单滑动平均（考虑前一次的均值）去除峰值的影响

统计 CPU 的滑动均值作为启发阈值(如 80%)，一旦触发进入过载保护阶段，算法：(pass * rt) < inflight

另外过载保护需要保证持续最小时间如 2s，以避免一个短时间的 CPU 下降可能导致大量请求被放行，严重是会打满 CPU
### 限流
定义：在一段时间内某个客户或应用可以处理多少个请求

作用：过滤流量峰值
#### 常规方案
* 令牌桶：针对单个节点无法分布式限流
* QPS 限流：
  * 不同的请求可能消耗的资源完全不同
  * 静态阈值很难设置准确
* 使用 redis 分布式限流
  * 单个大流量接口容易产生热点 key
  * 每次请求需要拿一个 quota –> 优化：基于历史窗口数据批量拿 quota，减少请求 redis 频次

转自：https://aliliin.com/2021/11/17/Go%20%E5%AD%A6%E4%B9%A0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8F%AF%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1/








