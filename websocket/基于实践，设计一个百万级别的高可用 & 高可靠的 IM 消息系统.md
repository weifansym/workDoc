![image](https://user-images.githubusercontent.com/6757408/203466747-875c5bbd-eb9a-4547-b142-ac63a0333a17.png)

### 写在开头
本人从事后台开发工作 3 年有余了，其中让我感触最深刻的一个项目，就是在两年前从架构师手上接过来的 IM 消息系统模块。
下面我将从开发者的视角出发，一步一步的与大家一起剖析：如何去设计一个能支撑起百万级别的高可用高可用的 IM 消息系统架构；
* 主要围绕着七个主题进行说明：项目背景、背景需求、实现原理、开发方案、对比方案、成果展示和参考文献。
![image](https://user-images.githubusercontent.com/6757408/203466879-17d66b1e-095b-4dc3-8cf3-85ae2f4e253c.png)

### 项目背景
我们仔细观察就能发现，生活中的任何类型互联网服务都有 IM 系统的存在，比如：
* 基础性服务类-腾讯新闻（评论消息）
* 商务应用类-钉钉（审批工作流通知）
* 交流娱乐类-QQ/微信（私聊群聊 &讨论组 &朋友圈）
* 互联网自媒体-抖音快手（点赞打赏通知）

![image](https://user-images.githubusercontent.com/6757408/203466965-c63b509d-9ded-4a43-b09b-067868c18fe6.png)

总结：在这些林林总总的互联网生态产品里，消息系统作为底层能力，在确保业务正常与用户体验优化上，始终扮演了至关重要的角色。

### 系统需求
我们将 IM 系统的需求需要满足四点：高可靠性、高可用性、实时性和有序性。
![image](https://user-images.githubusercontent.com/6757408/203467091-fa8bc4de-b359-44c1-8480-d3c31dbdbe9d.png)

### 架构设计
#### 4.1 架构设计
* IM 消息-微服务：拆分为用户微服务 &消息连接服务 &消息业务服务
* IM 消息-存储架构：兼容性能与资源开销，选择 reids&mysql
* IM 消息-高可用：可以支撑起高并发场景，选择 Spring 提供的 websocket
* IM 消息-支持多端消息同步：app 端、web 端、微信公众号、小程序消息
* IM 消息-支持在线与离线消息场景
#### 4.2 架构图
![image](https://user-images.githubusercontent.com/6757408/203467193-a7c81824-5119-49fd-8af3-ed5baa6c10f5.png)

#### 4.3 分层架构
![image](https://user-images.githubusercontent.com/6757408/203467230-50198d46-4cf0-4c69-9f5f-fe8bb42ea772.png)

### 实现原理
#### 5.1 消息存储模型
##### 5.1.1 读扩散和写扩散
**5.1.1.1 概念**
我们举个例子说明什么是读扩散，什么是写扩散：
一个群聊“相亲相爱一家人”，成员：爸爸、妈妈、哥哥、姐姐和我（共 5 人）；
![image](https://user-images.githubusercontent.com/6757408/203467371-4d893b9a-5b53-4083-9346-9c646dfeb2e9.png)

因为你最近交到女朋友了，所以发了一条消息“我脱单了”到群里面，那么自然希望爸爸妈妈哥哥姐姐四个亲人都能收到了。

**优化前的群聊消息发送的流程如下：**
1）遍历群聊的成员并发送消息；
2）查询每个成员的在线状态；
3）成员不在线的存储离线；
4）成员在线的实时推送。

数据模型如下：
![image](https://user-images.githubusercontent.com/6757408/203467454-f1b05e68-a923-4962-8d9c-1b60764c38a2.png)

**难点在于**：如果第四步发生异常，群友会丢失消息，那么会导致有家人不知道“你脱单了”，造成催婚的严重后果。所以优化的方案是：不管群员是否在线，都要先存储消息。

**一次优化后的发送群消息的流程优化如下：（写扩散）**
1）遍历群聊的成员并发送消息；
2）群聊所有人都存一份；
3）查询每个成员的在线状态；
4）在线的实时推送。
![image](https://user-images.githubusercontent.com/6757408/203467563-d4d28f4d-0028-4a32-bb58-2616856d17d2.png)

**难点在于**：每个人都存一份相同的“你脱单了”的消息，对磁盘和带宽造成了很大的浪费（这就是写扩散）。所以优化的方案是：群消息实体存储一份，用户只存消息 ID 索引。
**二次优化后的发送群消息的流程优化如下：（读扩散）**
1）遍历群聊的成员并发送消息；
2）先存一份消息实体；
3）然后群聊所有人都存一份消息实体的 ID 引用；
4）查询每个成员的在线状态；
5）在线的实时推送。
![image](https://user-images.githubusercontent.com/6757408/203467656-a932d474-9ae7-4990-8504-7cbe1dfd6ec8.png)

##### 5.1.1.2 特点
读扩散：读取操作很重，写入操作很轻；资源消耗相对小一些
写扩散：读取操作很轻，写入操作很重；资源消耗相对大一些

> 从公开的技术资料来看，微信的群聊消息应该使用的是存多份（即扩散写方式），详细的方案可以在微信团队分享的这篇文章里找到答案：
> [《微信后台团队：微信后台异步消息队列的优化升级实践分享》](http://www.52im.net/thread-801-1-1.html)。

### 5.1.2 消息模型
#### 5.1.2.1 消息数据模型
常见的消息业务需求，可以抽象为多个消息模型概念：用户/用户关系/用户设备/用户连接状态/消息/消息队列；
![image](https://user-images.githubusercontent.com/6757408/203467800-7ca52536-3e1b-4b1c-a078-f12196a29eb4.png)

#### 5.1.2.2 消息模型概念
1 用户
  * 用户->用户终端设备：每个用户能够多端登录并收发消息；
  * 用户->消息：考虑到读扩散，每个用户与消息的关系都是 1：n；
  * 用户->消息队列：考虑到读扩散，每个用户都会维护自己的一份“消息列表”（1:1），如果考虑到扩容，甚至可以开辟一份消息溢出列表接收超出“消息列表”容量的消息数据（此时是 1：n）；
  * 用户->用户连接状态：考虑到用户能够多端登录，那么 app/web 都会有对应的在线状态信息（1：n）；
  * 用户->联系人关系：考虑到用户最终以某种业务联系到一起，组成多份联系人关系，最终形成私聊或者群聊（1：n）；

2 联系人关系
  * 业务决定用户与用户之间的关系：比如说，某个家庭下有多少人，这个家庭群聊就有多少人；在 ToB 场景，在钉钉企业版里，我们往往有企业群聊这个存在；
3 消息
  * 消息->消息队列：考虑到读扩散，消息最终归属于一个或多个消息队列里，因此群聊场景它会分布在不同的消息队列里；

4. 消息队列
  * 消息队列：确切说是消息引用队列，它里面的索引元素最终指向具体的消息实体对象
5. 用户连接状态
  * 用户连接状态：
    * - 对于 app 端：网络原因导致断线，或者用户手动 kill 掉应用进程，都属于离线
    * - 对于 web 端：网络原因导致浏览器断网，或者用户手动关闭标签页，都属于离线
    * - 对于公众号：无法分别离线在线
    * - 对于小程序：无法分别离线在线
6. 用户终端设备
  * 终端设备：客户端一般是 Android&IOS，web 端一般是浏览器，还有其他灵活的 WebView（公众号/小程序）
#### 5.1.3 消息存储
对于消息存储方案，本质上只有三种方案：要么放在内存，要么放在磁盘，要么两者结合存储（据说大公司为了优化性能，活跃的消息数据都是放在内存里面的，毕竟有钱~）。
下面分别解析这两个方案的优点与弊端：
方案一、考虑性能，数据全部放到 redis 进行存储
方案二、考虑资源，数据用 redis + mysql 进行存储
##### 5.1.3.1 方案一：redis
* 前提
  * 用户 &联系人关系，由于是业务数据，因此统一默认使用关系型数据库存储
* 流程图
![image](https://user-images.githubusercontent.com/6757408/203468259-59c15847-c32f-4f86-92d4-f69db28bdbdd.png)

（1）用户发消息
（2）redis 创建一条实体数据 &一个实体数据计时器
（3）redis 在 B 用户的用户队列 添加实体数据引用
（4）B 用户拉取消息（后续 5.2 会提及拉模式）
* 解决方案
  * 用户队列，zset（score 确保有序性）
  * 消息实体列表，hash（msg_id 确保唯一性）
  * 消息实体计数器，hash（支持群聊消息的引用次数，倒计时到零时则删除实体列表的对应消息，以节省资源）
* 优点
  * 1、内存操作，响应性能好
* 弊端
  * 1、内存消耗巨大，eg：除非大厂，小公司的服务器的宝贵内存资源是耗不起业务的，随着业务增长，不想拓展资源，就需要手动清理数据了
  * 2、受 redis 容灾性策略影响较大，如果 redis 宕机，直接导致数据丢失（可以使用 redis 的集群部署/哨兵机制/主从复制等手段解决）
#### 5.1.3.2 方案二：redis+mysql
* 前提
  * 用户 &联系人关系，由于是业务数据，因此统一默认使用关系型数据库存储
* 流程图
![image](https://user-images.githubusercontent.com/6757408/203468467-65ffcc17-433e-4bf2-a5cc-bd74ca55b25a.png)

（1）用户发消息
（2）mysql 创建一条实体数据
（3）redis 在 B 用户的用户队列 添加实体数据引用
（4）B 用户拉取消息（5.2 会提及拉模式）
* 解决方案
  * 用户队列，zset（score 确保有序性）
  * 消息实体列表，转移到 mysql（表主键 id 确保唯一性）
  * 消息实体计数器，hash（删除这个概念，因为磁盘可用总资源远远高于内存总资源，哪怕一直存放 mysql 数据库，在业务量百万级别时也不会有大问题，如果是巨大体量业务就需要考虑分表分库处理检索数据的性能了）
* 优点：
  * 1、抽离了数据量最大的消息实体，大大节省了内存资源
  * 2、磁盘资源易于拓展 ，便宜实用
* 弊端：
  * 1、磁盘读取操作，响应性能较差（从产品设计的角度出发，你维护的这套 IM 系统究竟是强 IM 还是弱 IM）
  
  
  转自：https://xie.infoq.cn/article/4061081a5ce66137a8c021994
  https://developer.baidu.com/article/detail.html?id=293527

