你好，我是孔令飞，我们又见面了。结课并不意味着结束，我非常高兴能持续把好的内容分享给你，也希望你能继续在留言区与我保持交流，分享你的学习心得和实践经验。

今天这一讲，我们来聊聊如何设计分布式作业系统。在实际的Go项目开发中，我们经常会遇到下面这两个功能需求：
* 想定时执行某个任务，例如在每天上午10:00清理数据库中的无用数据。
* 轮训数据库表的某个字段，根据字段的状态，进行一些异步的业务逻辑处理。比如，监听到 table_xxx.status = 'pending' 时，执行异步的初始化流程，完成之后设置 table_xxx.status='normal' 。

这两个在Go项目开发中非常常见、基础的功能需求，通常可以通过作业系统来实现。IAM为了解决这种常见的功能需求，也开发了自己的作业系统。今天这一讲，我们就来看下IAM是如何实现作业系统的。
## 任务分类
在介绍作业系统之前，这里先来看下任务的分类。理解任务的分类，有助于我们理解作业系统执行的任务类型，进而有助于我们设计作业系统。

在我看来，任务可以分为下面3类。
* 定时任务：定时任务会在指定的时间点固定执行。只要到达执行任务的时间点，就会执行任务，而**不管上一次任务是否完成。**
* 间隔任务：**上一次任务执行完**，间隔一段时间（如5秒、5分钟），再继续执行下一次任务。
* 间隔性定时任务：间隔任务的变种，从上一次任务开始执行时计时，**只要间隔时间一到**，便执行下一次任务，而**不管上一次任务是否完成。**

定时任务好理解，但间隔任务和间隔性定时任务不太好区分，它们的区别是：间隔任务会等待上一次任务执行完，间隔一段时间再执行下一次任务。而间隔性定时任务不会等待上一次任务执行完，只要间隔时间一到，便执行下一次任务。

三者的区别如下图所示：
![image](https://github.com/weifansym/workDoc/assets/6757408/0cce4462-4ce0-4197-b2a5-4285e0300d73)

## 作业系统的常见实现
在开始介绍IAM作业系统实现之前，有必要先介绍一下如何执行一个间隔/定时任务。只有了解了这些，才能更好地设计IAM的作业系统。通常来说，我们可以通过以下4种方式，来执行一个间隔/定时任务：
1. 基于time 包提供的方法（例如time.Sleep、time.Ticker等 ）自己开发执行间隔/定时任务的服务。
2. 一些Go包支持执行间隔/定时任务，可以直接使用这些Go包来执行间隔/定时任务，免去了自己开发作业调度部分的代码，例如github.com/robfig/cron 。
3. 借助Linux的crontab执行定时任务。
4. 使用开源的作业系统，并通过作业系统来执行间隔/定时任务，例如[distribworks/dkron](https://github.com/distribworks/dkron)。

上述4种方法，每一种都有自己的优缺点。采用第一种方法的话，因为一切都要从0开始实现，开发工作量大、开发效率低。我认为，因为已经有很多优秀的cron包可供使用了，没必要自己从0开发，可以直接使用这些cron包来执行周期/定时任务。IAM项目便采用了这种方法。

接下来，我先介绍下第三种和第四种方法：使用Linux crontab和使用开源的Go作业系统。然后，我们再来重点看看IAM项目采用的第二种方法。

## Linux crontab
crontab是Linux系统自带的定时执行工具，可以在无需人工干预的情况下运行作业。crontab通过crond进程来提供服务，crond进程每分钟会定期检查是否有要执行的任务，如果有，则自动执行该任务。crond进程通过读取crontab配置，来判断是否有任务执行，以及何时执行。

crond进程会在下面这3个位置查找crontab配置文件。
* /var/spool/cron/：该目录存放用户（包括root）的crontab任务，每个任务以登录名命名，比如 colin 用户创建的crontab任务对应的文件就是/var/spool/cron/colin。
* /etc/crontab：该目录存放由系统管理员创建并维护的crontab任务。
* /etc/cron.d/：该目录存放任何要执行的crontab任务。cron进程执行时，会自动扫描该目录下的所有文件，按照文件中的时间设定执行后面的命令。

可以看到，如果想执行一个crontab任务，就需要确保crond运行，并配置crontab任务。具体分为以下两步：
#### 第一步，确保crond进程正在运行。
执行以下命令，查看crond进程运行状态：
```
$ systemctl status crond● crond.service - Command Scheduler   Loaded: loaded (/usr/lib/systemd/system/crond.service; enabled; vendor preset: enabled)   Active: active (running) since Wed 2021-11-17 07:11:27 CST; 2 days ago Main PID: 9182 (crond)    Tasks: 1   Memory: 728.0K   CGroup: /system.slice/crond.service           └─9182 /usr/sbin/crond -n
```
Active: active (running)说明crond进程正在运行，否则可以执行systemctl start crond启动crond进程。

#### 第二步，配置crontab任务。
可以通过crontab -e来编辑配置文件，例如执行crontab -e后进入vi交互界面，并配置以下crontab任务：
```
# 每分钟输出时间到文件 /tmp/test.txt*  *  *  *  * echo date >> /tmp/test.txt# 每隔 2 分钟同步一次互联网时间*/2 * * * * /usr/bin/ntpstat time.windows.com > /dev/null 2>&1
```
编辑后的配置文件保存在/var/spool/cron/$USER文件中。你可以通过crontab -l或者sudo cat /var/spool/cron/$USER来查看，例如：
```
$ crontab -l# 每分钟输出时间到文件/tmp/test.txt*  *  *  *  * echo date >> /tmp/test.txt# 每隔 2 分钟同步一次互联网时间*/2 * * * * /usr/bin/ntpstat time.windows.com > /dev/null 2>&1
```
如果想删除所有的crontab任务，你可以执行crontab -r命令。

配置的crontab任务需要遵循crontab的时间格式，格式如下：
```
.---------------- minute (0 - 59)    |  .------------- hour (0 - 23)    |  |  .---------- day of month (1 - 31)    |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...    |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat    |  |  |  |  |    *  *  *  *  * <command to be executed>
```
可以看到，crontab只能精确到分钟，不能精确到秒。

下面是一些常用的crontab时间格式，你可以参考，来加深理解：
```
# 每分钟执行一次 <command>            * * * * * <command> # * 代表所有可能的值# 每隔一小时执行一次 <command>* */1 * * * <command> # / 表示频率# 每小时的 15 和 30 分各执行一次 <command>15,45 * * * * <command> # , 表示并列# 在每天上午 8- 11 时中间每小时 15，45 分各执行一次 <command>15,45 8-11 * * * <command> # - 表示范围# 每个星期一的上午 8 点到 11 点的第 3 和第 15 分钟执行一次 <command>3,15 8-11 * * 1 <command># 每隔两天的上午 8 点到 11 点的第 3 和第 15 分钟执行一次 <command>3,15 8-11 /2 * * <command>
```
使用crontab执行周期/定时任务的优点是不用做任何开发，只需要配置crontab任务即可。至于缺点也很明显，主要有下面这几个：
* 不能精确到秒。
* 需要手动编写可执行命令。这些可执行命令跟项目分离，没办法复用项目提供的包、函数等能力。如果想执行跟项目关系紧密的作业，开发起来不方便。
* 单点，如果crond进程异常，周期/定时任务就没法继续执行。你可能想说：可以在两台机器上配置并执行相同的周期/定时任务。但是这样做会有问题，因为两台机器同时执行相同的任务，可能会彼此造成冲突或状态不一致。
* 没办法实现间隔任务和间隔性定时任务。

### 使用开源的作业系统
除了使用Linux系统自带的crontab之外，我们还可以使用一些业界优秀的开源作业系统。这里，我列出了一些比较受欢迎的Go语言开发的作业系统。之所以只选择Go语言开发的项目，一方面是想丰富你的Go语言生态，另一方面，同种语言也有助于你学习、改造这些项目。
* distribworks/dkron。dkron是一个分布式、启动迅速、带容错机制的定时作业系统，支持crontab表达式。它具有下面这些核心特性。
  * 易用：可以通过易操作、漂亮的Web界面来管理作业。
  * 可靠：具备容错机制，一个节点不可用，其他节点可继续执行作业。
  * 高可扩展性：能够处理大量的计划作业和数千个节点。
 
* ouqiang/gocron。gocron是国人开发的轻量级定时任务集中调度和管理系统, 用于替代Linux-crontab。它具有下面这些核心特性。
  * 具有Web界面管理定时任务。
  * 支持crontab时间格式，并精确到秒。
  * 支持shell命令和HTTP请求两种任务格式。
  * 具有任务超时机制、任务依赖机制、任务执行失败可重试机制。
  * 支持查看任务执行日志，并支持用邮件、Slack、Webhook等方式通知任务执行结果。
 
* shunfei/cronsun。cronsun 是一个分布式作业系统，单个节点同 crontab 近似。它具有下面这些核心特性。
  * 具有Web界面，方便对多台服务器上的定时任务进行集中式管理。
  * 任务调度时间粒度支持到秒级别。
  * 任务执行失败可重试。
  * 任务可靠性保障（从N个节点里面挑一个可用节点来执行任务）。
  * 任务日志查看。
  * 任务失败邮件告警（也支持自定义http告警接口）。

那么，这么多的开源项目该如何选择呢？这里建议你选择 distribworks/dkron 。原因是 distribworks/dkron Star数很多，而且功能齐全易用、文档丰富。当然，在实际开发中，你最好也对其他开源项目进行调研，根据需要选择一个最适合自己的开源项目。

使用这些作业系统的优点是不用开发、功能比crontab更强大，有些还是分布式的作业系统，具备容灾能力。但缺点也很明显：
* 这些作业系统支持的任务种类有限，比如一般会支持通过shell脚本及发送HTTP请求的方式来执行任务。不管哪种方式，实现都跟项目分离，在开发跟项目结合紧密的任务插件时不是很简单、高效。
* 很多时候我们只会使用其中一部分能力，或者仅有一到两个项目会使用到这类系统，但我们还要部署并维护这些作业系统，工作量大，收益小。
* 没办法实现间隔任务。

使用Linux的crontab和使用开源的Go作业系统，这两种方法的缺点都很明显。鉴于这些缺点，IAM系统选择使用现有的cron库封装自己的任务框架，并基于这个框架开发任务。IAM项目选择了robfig/cron库，原因是cron库Star数最多，且功能丰富、使用简单。另外IAM还使用github.com/go-redsync/redsync实现了基于Redis的分布式互斥锁。所以，在开始介绍IAM作业系统实现前，我先来简单介绍下如何使用这两个包。

### github.com/robfig/cron使用介绍
github.com/robfig/cron是一个可以实现类似Linux crontab定时任务的cron包，但是cron包支持到秒。

cron包支持的时间格式
cron包支持crontab格式和固定间隔格式这两种时间格式，下面我来分别介绍下。

crontab格式的时间格式，支持的匹配符跟crontab保持一致。时间格式如下：


转自：https://leeshengis.com/archives/469884







